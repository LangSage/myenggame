<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>Blind Fault Maze</title>
<style>
  :root {
    --hud-bg: rgba(0,0,0,.6);
    --accent: #10b981; /* teal-ish for minimal UI hints */
    --danger: #ef4444;
    --text: #e5e7eb;
  }
  html, body { height:100%; margin:0; background:#000; color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
  #game { position:fixed; inset:0; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; touch-action:none; }
  /* HUD */
  .hud {
    position: fixed; left: 0; right: 0; top: env(safe-area-inset-top, 0);
    padding: .5rem .75rem; display:flex; gap:.5rem; align-items:center; justify-content:space-between;
    background: linear-gradient(to bottom, rgba(0,0,0,.85), rgba(0,0,0,.2));
    pointer-events: none; user-select:none;
  }
  .hud > * { pointer-events:auto; }
  .pill {
    background: var(--hud-bg); border: 1px solid rgba(255,255,255,.08);
    padding: .4rem .6rem; border-radius: 999px; font-size: .9rem; display:inline-flex; gap:.6rem; align-items:center;
  }
  .btn {
    background: var(--hud-bg); border:1px solid rgba(255,255,255,.08);
    color: var(--text); padding: .5rem .8rem; border-radius: .75rem;
    font-weight: 600; letter-spacing:.2px; cursor:pointer; transition: transform .08s ease;
  }
  .btn:active { transform: scale(.98); }
  .btn-accent { border-color: rgba(16,185,129,.45); box-shadow: 0 0 0 1px rgba(16,185,129,.15) inset; }
  .btn-danger { border-color: rgba(239,68,68,.4); }
  .toggle { display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; user-select:none; }
  .toggle input { accent-color: var(--accent); width:1rem; height:1rem; }
  /* D-Pad */
  .pad {
    position: fixed; left: 0; right: 0; bottom: calc(env(safe-area-inset-bottom, 0) + .5rem);
    display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 64px; gap:.5rem; padding: 0 .75rem;
  }
  .pad .btn { font-size:1.15rem; }
  .pad .sp { visibility:hidden; }
  /* Overlays */
  .overlay {
    position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background: radial-gradient(ellipse at center, rgba(0,0,0,.65), rgba(0,0,0,.9) 60%, #000 100%);
    backdrop-filter: blur(2px);
  }
  .card {
    width:min(560px, 92vw); border-radius: 1rem; padding: 1rem; background: rgba(17,24,39,.8); border:1px solid rgba(255,255,255,.08);
    box-shadow: 0 10px 30px rgba(0,0,0,.4);
  }
  .card h1 { margin:.2rem 0 .6rem; font-size:1.4rem; }
  .muted { color:#9ca3af; font-size:.95rem; }
  .row { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
  input, select { background:#0b0f17; color:var(--text); border:1px solid rgba(255,255,255,.08); border-radius:.6rem; padding:.5rem .6rem; }
  .key {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    background: #0b0f17; border:1px solid rgba(255,255,255,.08); padding:.1rem .4rem; border-radius:.4rem;
  }
  /* FX flashes */
  .flash-red { animation: flash .25s ease; }
  @keyframes flash { 0%{background:rgba(239,68,68,.25);} 100%{background:transparent;} }
  /* Tiny footer */
  .footer {
    position:fixed; right:.5rem; bottom: calc(env(safe-area-inset-bottom, 0) + 4.8rem);
    font-size:.8rem; color:#6b7280; opacity:.85; background:var(--hud-bg); padding:.25rem .5rem; border-radius:.5rem;
  }
</style>
</head>
<body>
<div id="game">
  <canvas id="c"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="pill">
      <span>Deaths: <strong id="deaths">0</strong></span>
      <span>Steps: <strong id="steps">0</strong></span>
      <span>Time: <strong id="time">00:00</strong></span>
    </div>
    <div class="row">
      <button class="btn btn-accent" id="btnPing" title="Echo ping (3 uses)">Echo (3)</button>
      <label class="toggle"><input type="checkbox" id="assist" /> Assist blink</label>
      <button class="btn" id="btnMute">üîä</button>
      <button class="btn btn-danger" id="btnReset">Reset</button>
    </div>
  </div>

  <!-- D-Pad -->
  <div class="pad">
    <span class="sp"></span>
    <button class="btn" id="btnUp">‚ñ≤</button>
    <span class="sp"></span>
    <button class="btn" id="btnLeft">‚óÄ</button>
    <button class="btn" id="btnCenter" title="Stand / Ping via long-press">‚óè</button>
    <button class="btn" id="btnRight">‚ñ∂</button>
    <span class="sp"></span>
    <button class="btn" id="btnDown">‚ñº</button>
    <span class="sp"></span>
  </div>

  <div class="footer">Swipe or use the D-pad. Long-press center for Echo.</div>

  <!-- Start overlay -->
  <div class="overlay" id="startOverlay">
    <div class="card">
      <h1>Blind Fault Maze</h1>
      <p class="muted">The world is black. Some tiles are deadly ‚Äúfault pits‚Äù. You can‚Äôt see them. Move, die, and <em>draw your own paper map</em> to learn the safe route. Reach the exit.</p>
      <ul class="muted" style="line-height:1.5;margin:.5rem 0 1rem;padding-left:1rem;">
        <li>Controls: D-pad, swipe, or keys <span class="key">WASD</span>/<span class="key">‚Üë‚Üê‚Üì‚Üí</span></li>
        <li>Echo (3): a short sonar beep ‚Äî higher pitch means danger nearby (no map reveal)</li>
        <li>For realism, enable ‚ÄúPure blind‚Äù: keep <em>Assist blink</em> OFF</li>
      </ul>
      <div class="row" style="margin-bottom:.6rem;">
        <label>Size:
          <select id="sizeSel">
            <option value="15">Small (15√ó15)</option>
            <option value="20" selected>Medium (20√ó20)</option>
            <option value="25">Large (25√ó25)</option>
            <option value="30">Huge (30√ó30)</option>
          </select>
        </label>
        <label>Seed: <input id="seedInput" placeholder="(blank = daily seed)" size="14" /></label>
      </div>
      <div class="row" style="margin-bottom:.6rem;">
        <button class="btn btn-accent" id="btnStart">Start</button>
        <button class="btn" id="btnDaily">Use Today‚Äôs Seed</button>
        <button class="btn" id="btnRandom">Random Seed</button>
        <button class="btn" id="btnPrint">Print blank grid</button>
      </div>
      <p class="muted">Audio: background <span class="key">back.mp3</span>, lose <span class="key">lose.mp3</span>. Replace these with your links.</p>
    </div>
  </div>

  <!-- Win overlay -->
  <div class="overlay" id="winOverlay" style="display:none;">
    <div class="card">
      <h1>Exit Found! üéâ</h1>
      <p class="muted">Seed <span id="winSeed" class="key"></span> ‚Äî Size <span id="winSize" class="key"></span></p>
      <div class="pill" style="margin:.5rem 0 1rem; display:inline-flex;">
        <span>Deaths: <strong id="sumDeaths"></strong></span>
        <span>Steps: <strong id="sumSteps"></strong></span>
        <span>Time: <strong id="sumTime"></strong></span>
      </div>
      <p class="muted">Best for this seed: <span id="bestLine">‚Äî</span></p>
      <div class="row">
        <button class="btn btn-accent" id="btnReplay">Replay</button>
        <button class="btn" id="btnNewRun">New Run</button>
        <button class="btn" id="btnCopySeed">Copy seed</button>
      </div>
    </div>
  </div>
</div>

<!-- Audio -->
<audio id="bgm" src="back.mp3" preload="auto" loop></audio>
<audio id="lose" src="lose.mp3" preload="auto"></audio>

<script>
/* ========= Utilities ========= */
const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
function pad2(n){ return (n<10?'0':'')+n; }
function fmtTime(s){ const m = Math.floor(s/60), ss = Math.floor(s%60); return pad2(m)+':'+pad2(ss); }
function todaySeed(){
  const d = new Date(); const y=d.getFullYear(), m=d.getMonth()+1, day=d.getDate();
  return `D${y}${pad2(m)}${pad2(day)}`;
}
function randomSeed(){ return 'S' + Math.random().toString(36).slice(2, 10).toUpperCase(); }

// Mulberry32 seeded PRNG
function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; }; }
function hashStr(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); } return h>>>0; }

/* ========= Game State ========= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let DPR = Math.max(1, Math.min(2, devicePixelRatio || 1)); // keep modest for phones

let N = 20;                // grid size
let cellPx = 24;           // will be recalculated to fit screen
let rng = mulberry32(1);
let seed = todaySeed();

let safe;                  // boolean grid [y][x] = true if safe cell (corridor), false = pit
let start = {x:0, y:0};
let exitC = {x:0, y:0};

let player = { x:0, y:0 };
let steps = 0, deaths = 0, startTime = 0, timeSec = 0, timerId = null;
let echoUses = 3;
let assistBlink = false;
let assistGlowT = 0;       // short-lived blink for safe step if assist on
let running = false;

const els = {
  deaths: document.getElementById('deaths'),
  steps: document.getElementById('steps'),
  time: document.getElementById('time'),
  btnReset: document.getElementById('btnReset'),
  btnMute: document.getElementById('btnMute'),
  btnPing: document.getElementById('btnPing'),
  assist: document.getElementById('assist'),
  startOverlay: document.getElementById('startOverlay'),
  winOverlay: document.getElementById('winOverlay'),
  sumDeaths: document.getElementById('sumDeaths'),
  sumSteps: document.getElementById('sumSteps'),
  sumTime: document.getElementById('sumTime'),
  winSeed: document.getElementById('winSeed'),
  winSize: document.getElementById('winSize'),
  bestLine: document.getElementById('bestLine'),
  btnReplay: document.getElementById('btnReplay'),
  btnNewRun: document.getElementById('btnNewRun'),
  btnCopySeed: document.getElementById('btnCopySeed'),
  sizeSel: document.getElementById('sizeSel'),
  seedInput: document.getElementById('seedInput'),
  btnStart: document.getElementById('btnStart'),
  btnDaily: document.getElementById('btnDaily'),
  btnRandom: document.getElementById('btnRandom'),
  btnPrint: document.getElementById('btnPrint'),
  padUp: document.getElementById('btnUp'),
  padDown: document.getElementById('btnDown'),
  padLeft: document.getElementById('btnLeft'),
  padRight: document.getElementById('btnRight'),
  padCenter: document.getElementById('btnCenter'),
  bgm: document.getElementById('bgm'),
  lose: document.getElementById('lose'),
};

function resize(){
  const w = innerWidth, h = innerHeight;
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  // choose cell size to fit with margins
  const maxCellW = Math.floor((canvas.width * 0.85) / N);
  const maxCellH = Math.floor((canvas.height * 0.70) / N);
  cellPx = Math.max(10, Math.min(maxCellW, maxCellH));
}
addEventListener('resize', resize);

/* ========= Maze Generation (safe cells) =========
   Perfect maze via DFS; safe = corridor cells visited.
*/
function generate(){
  rng = mulberry32(hashStr(seed));
  // grid of walls initially false (unsafe), mark visited path as safe
  safe = Array.from({length:N}, ()=> Array(N).fill(false));
  const stack = [];
  const visited = Array.from({length:N}, ()=> Array(N).fill(false));
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

  start = {x:0, y:0};
  exitC = {x:N-1, y:N-1};

  // DFS from start; create a wiggly path to exit ensuring solvable
  stack.push({...start}); visited[start.y][start.x]=true; safe[start.y][start.x]=true;
  let last = {...start};
  while(stack.length){
    const cur = stack[stack.length-1];
    // Fisher-Yates shuffle dirs
    for(let i=dirs.length-1;i>0;i--){ const j=(rng()* (i+1))|0; [dirs[i],dirs[j]]=[dirs[j],dirs[i]]; }
    let pushed=false;
    for(const [dx,dy] of dirs){
      const nx = cur.x+dx, ny = cur.y+dy;
      if(nx<0||ny<0||nx>=N||ny>=N) continue;
      if(!visited[ny][nx]){
        visited[ny][nx]=true; safe[ny][nx]=true; stack.push({x:nx,y:ny}); pushed=true; last={x:nx,y:ny}; break;
      }
    }
    if(!pushed) stack.pop();
  }
  // Make sure exit is safe (it already is via DFS). Optionally open a few random safe islands to reduce frustration
  const extra = Math.floor(N*N * 0.08); // ~8% extra safe
  for(let k=0;k<extra;k++){
    const x = (rng()*N)|0, y=(rng()*N)|0; safe[y][x]=true;
  }
  player = {...start};
  steps = deaths = 0; timeSec = 0; echoUses = 3;
  updateHUD();
}

function updateHUD(){
  els.deaths.textContent = deaths;
  els.steps.textContent = steps;
  els.time.textContent = fmtTime(timeSec);
  els.btnPing.textContent = `Echo (${echoUses})`;
}

function startTimer(){
  if(timerId) clearInterval(timerId);
  startTime = Date.now();
  timerId = setInterval(()=>{
    timeSec = (Date.now() - startTime)/1000;
    els.time.textContent = fmtTime(timeSec);
  }, 250);
}

/* ========= Render ========= */
function render(){
  // black background
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // compute viewport translation to center grid
  const totalW = N * cellPx, totalH = N * cellPx;
  const offX = Math.floor((canvas.width - totalW) / 2);
  const offY = Math.floor((canvas.height - totalH) / 2);

  // Assist blink (very faint flash on player cell when moving, if enabled)
  if(assistBlink && assistGlowT>0){
    const a = Math.max(0, Math.min(1, assistGlowT / 200));
    ctx.fillStyle = `rgba(255,255,255,${0.08 * a})`;
    ctx.fillRect(offX + player.x*cellPx, offY + player.y*cellPx, cellPx, cellPx);
    assistGlowT -= 16;
  }

  // Exit indicator: a subtle pulsing ring (still hard to use without a paper map)
  // We keep it *very* faint so mapping is still required.
  const t = performance.now()/1000;
  const pulse = (Math.sin(t*2)+1)/2 * .35 + .1;
  ctx.strokeStyle = `rgba(255,255,255,${pulse*0.12})`;
  ctx.lineWidth = Math.max(1, Math.floor(cellPx*0.06));
  const ex = offX + (exitC.x+0.5)*cellPx, ey = offY + (exitC.y+0.5)*cellPx;
  ctx.beginPath();
  ctx.arc(ex, ey, cellPx*0.45, 0, Math.PI*2);
  ctx.stroke();

  // Player: bright dot
  ctx.fillStyle = '#fff';
  const px = offX + (player.x+0.5)*cellPx, py = offY + (player.y+0.5)*cellPx;
  ctx.beginPath();
  ctx.arc(px, py, Math.max(2, cellPx*0.22), 0, Math.PI*2);
  ctx.fill();

  requestAnimationFrame(render);
}

/* ========= Movement & Rules ========= */
function lose(){
  deaths++;
  updateHUD();
  // flash & sound & vibrate
  document.body.classList.add('flash-red');
  setTimeout(()=>document.body.classList.remove('flash-red'), 180);
  try{ els.lose.currentTime = 0; els.lose.play().catch(()=>{});}catch{}
  if(navigator.vibrate) navigator.vibrate([80, 40, 80]);
  // reset to start
  player = {...start};
}

function checkWin(){
  if(player.x === exitC.x && player.y === exitC.y){
    running = false;
    clearInterval(timerId); timerId = null;
    // store best
    const key = `BFM_${seed}_${N}`;
    const prev = JSON.parse(localStorage.getItem(key) || 'null');
    const cur = { deaths, steps, time: timeSec };
    let bestStr = '‚Äî';
    if(!prev || cur.deaths < prev.deaths || (cur.deaths === prev.deaths && cur.time < prev.time)){
      localStorage.setItem(key, JSON.stringify(cur));
      bestStr = `new best! üéØ deaths ${cur.deaths}, time ${fmtTime(cur.time)}`;
    } else {
      bestStr = `best stays: deaths ${prev.deaths}, time ${fmtTime(prev.time)}`;
    }
    // show overlay
    els.winSeed.textContent = seed;
    els.winSize.textContent = `${N}√ó${N}`;
    els.sumDeaths.textContent = deaths;
    els.sumSteps.textContent = steps;
    els.sumTime.textContent = fmtTime(timeSec);
    els.bestLine.textContent = bestStr;
    els.winOverlay.style.display = 'flex';
    // fade bgm slightly
    fadeBgm(0.3, 300);
  }
}

function move(dx, dy){
  if(!running) return;
  const nx = clamp(player.x + dx, 0, N-1);
  const ny = clamp(player.y + dy, 0, N-1);
  if(nx === player.x && ny === player.y) return;

  steps++;
  player.x = nx; player.y = ny;
  if(els.assist.checked){ assistBlink = true; assistGlowT = 220; }
  updateHUD();

  // If cell is unsafe (pit), you lose
  if(!safe[ny][nx]){
    lose();
    return;
  }
  checkWin();
}

/* ========= Echo sonar (cool extra) =========
   3 uses: plays a short WebAudio beep.
   Pitch increases when the nearest pit within radius (5) is close.
   Does NOT reveal the map visually.
*/
let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function echoPing(){
  if(!running || echoUses<=0) return;
  echoUses--;
  updateHUD();
  ensureAudioCtx();
  const minD = nearestPitDistance(player.x, player.y, 5); // 0..5 (0 means current cell is pit; impossible if safe)
  // map distance to frequency and duration
  const freq = 220 + (5 - minD) * 90;   // closer => higher
  const dur = 0.12 + (5 - minD) * 0.02;
  const gain = audioCtx.createGain();
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  gain.gain.value = 0.0001;
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  // quick attack/decay
  const now = audioCtx.currentTime;
  gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  osc.stop(now + dur + 0.02);
  // tiny screen blink to feel the ping
  assistBlink = true; assistGlowT = 120;
  if(navigator.vibrate) navigator.vibrate(25);
}

function nearestPitDistance(x,y, R){
  let best = 6;
  for(let dy=-R; dy<=R; dy++){
    for(let dx=-R; dx<=R; dx++){
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=N||ny>=N) continue;
      if(!safe[ny][nx]){ const d = Math.abs(dx)+Math.abs(dy); if(d<best) best = d; }
    }
  }
  return best;
}

/* ========= Input ========= */
function bindPad(btn, dx, dy){
  let hold=null;
  const go=()=>move(dx,dy);
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); go(); hold=setInterval(go, 160); });
  btn.addEventListener('mousedown', e=>{ e.preventDefault(); go(); hold=setInterval(go, 160); });
  const stop=()=>{ if(hold){ clearInterval(hold); hold=null; } };
  btn.addEventListener('touchend', stop); btn.addEventListener('touchcancel', stop);
  btn.addEventListener('mouseup', stop); btn.addEventListener('mouseleave', stop);
}
bindPad(els.padUp, 0, -1);
bindPad(els.padDown, 0, 1);
bindPad(els.padLeft, -1, 0);
bindPad(els.padRight, 1, 0);

// Center button: single tap = no-op; long press = Echo
(function(){
  let t0=0, timer=null;
  const down = (e)=>{ e.preventDefault(); t0=Date.now(); timer=setTimeout(()=>{ echoPing(); timer=null; }, 350); };
  const up = ()=>{ if(timer){ clearTimeout(timer); timer=null; } };
  ['touchstart','mousedown'].forEach(ev=>els.padCenter.addEventListener(ev, down));
  ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>els.padCenter.addEventListener(ev, up));
})();

// Swipe
let touchStart = null;
canvas.addEventListener('touchstart', e=>{
  if(!running) return;
  const t = e.changedTouches[0];
  touchStart = { x:t.clientX, y:t.clientY, t: Date.now() };
});
canvas.addEventListener('touchend', e=>{
  if(!running || !touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if(Math.max(adx, ady) > 24){
    if(adx > ady) move(dx>0?1:-1, 0); else move(0, dy>0?1:-1);
  }
  touchStart = null;
});

// Keyboard
addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(['arrowup','w'].includes(k)) { move(0,-1); e.preventDefault(); }
  else if(['arrowdown','s'].includes(k)) { move(0,1); e.preventDefault(); }
  else if(['arrowleft','a'].includes(k)) { move(-1,0); e.preventDefault(); }
  else if(['arrowright','d'].includes(k)) { move(1,0); e.preventDefault(); }
  else if(k===' '){ echoPing(); e.preventDefault(); }
});

/* ========= Audio ========= */
let muted = false;
function fadeBgm(target=0.7, ms=300){
  const a = els.bgm;
  const start = a.volume;
  const t0 = performance.now();
  function step(){
    const p = clamp((performance.now()-t0)/ms, 0, 1);
    a.volume = start + (target - start) * p;
    if(p<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}
function startBgm(){
  if(muted) return;
  els.bgm.volume = 0; els.bgm.play().then(()=>fadeBgm(0.6, 500)).catch(()=>{ /* user gesture needed */ });
}
function toggleMute(){
  muted = !muted;
  els.bgm.muted = muted;
  els.lose.muted = muted;
  els.btnMute.textContent = muted ? 'üîá' : 'üîä';
}

/* ========= Start / Reset / Seed ========= */
function startRun(){
  N = parseInt(els.sizeSel.value, 10);
  seed = (els.seedInput.value.trim() || todaySeed()).toUpperCase();
  generate();
  resize();
  running = true;
  timeSec = 0;
  updateHUD();
  startTimer();
  els.startOverlay.style.display = 'none';
  els.winOverlay.style.display = 'none';
  startBgm();
}
function resetRun(){
  generate();
  timeSec = 0; startTime = Date.now();
  updateHUD();
  if(!muted) fadeBgm(0.6, 150);
}
function replayRun(){
  // same seed & size, just restart
  els.winOverlay.style.display = 'none';
  startRun();
}
function newRun(){
  // same size, new random seed
  els.seedInput.value = randomSeed();
  els.winOverlay.style.display = 'none';
  startRun();
}

/* ========= Print blank grid ========= */
function printGrid(){
  const size = parseInt(els.sizeSel.value, 10);
  const html = `
  <!doctype html><html><head><meta charset="utf-8"><title>Grid ${size}√ó${size}</title>
  <style>
  body{margin:20px;font-family:system-ui}
  h1{font-size:16px;margin:0 0 10px}
  table{border-collapse:collapse}
  td{width:22px;height:22px;border:1px solid #444}
  @media print { body{margin:0} td{width:18px;height:18px} }
  </style></head>
  <body>
  <h1>Blind Fault Maze ‚Äî ${size}√ó${size} (seed: ${(els.seedInput.value.trim()||todaySeed()).toUpperCase()})</h1>
  <table>
  ${Array.from({length:size}, (_,y)=>'<tr>'+Array.from({length:size},(_,x)=>'<td></td>').join('')+'</tr>').join('')}
  </table>
  </body></html>`;
  const w = window.open('', '_blank'); w.document.write(html); w.document.close();
}

/* ========= Buttons ========= */
els.btnStart.addEventListener('click', startRun);
els.btnDaily.addEventListener('click', ()=>{ els.seedInput.value = todaySeed(); });
els.btnRandom.addEventListener('click', ()=>{ els.seedInput.value = randomSeed(); });
els.btnPrint.addEventListener('click', printGrid);
els.btnReset.addEventListener('click', resetRun);
els.btnPing.addEventListener('click', echoPing);
els.btnMute.addEventListener('click', toggleMute);
els.btnReplay.addEventListener('click', replayRun);
els.btnNewRun.addEventListener('click', newRun);
els.btnCopySeed.addEventListener('click', ()=>{
  const s = `Seed: ${seed}, Size: ${N}√ó${N}`;
  navigator.clipboard?.writeText(s);
});

/* ========= Boot ========= */
resize();
render();
</script>
</body>
</html>
